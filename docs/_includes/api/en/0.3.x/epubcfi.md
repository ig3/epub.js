<h2 id="epubcfi">EpubCFI(url, [options])</h2>

Constructs a new epubjs Book object for the book at the given url.

```js
const book = new Book('https://epub.server.example.com/path/to/book.epub');
```

<h3 id='epubcfi.methods'>Methods</h3>

<h4 id="epubcfi.toRange">toRange(document, ignoreClass)</h4>

Creates a DOM range corresponding to the CFI of the EpubCFI instance.

Returns: {Range} - the DOM range containing the range of the EpubCFI.

Arguments:

 * `document` (document) - ???. **Default**: global document.
 * `ignoreClass` (string) - a class to be ignored in computing the range.

The EpubCFI instance may be a range or a single point. In the case of a
single point (i.e. start but no stop) the range has no end (so, what
happens??? Does it default to the end of the content or a range with no
length???)


This, presumably, is the function that is going wrong in some of my epub
books, causing different epubcfi values that correspond to different pages
to result in the same page being display: either the correct page or an
earlier page.

The problem might be that when displaying an epubcfi, the page displayed is
the one that contains the start of the 'location' (a.k.a. range) that
contains the point indicated in the epubcfi and, because the location
ranges are 150 characters, this might be on the previous page to the page
containing the actual point of the epubcfi???

Or perhaps, the problem is that the epubcfi returned for a page is actually
the epubcfi of the start of the element in the source document that
contains the start of the currently displayed page, but that element might
be split across page boundaries so that the start of the source element
that contains the text at the start of the current page is actually on the
previous page (or some previous page if the element is very long - e.g. a
very long paragraph that spans multiple pages in the rendered display).

So, maybe the actual fault is that an incorrect (i.e. missing offset into
the element) epubcfi is generated to indicate the location of a page, when
that page begins with content that is not at the start of the source
element.

This latter possibility seems consistent with the fact that scrolling
through a problematic book (maybe they all are???) the epubcfi for every
page has an offset into the text element of 0, even when the start of the
page is clearly offset in the text (e.g. the paragraph began on the
previous page and only the end of the paragraph is displayed at the start
of the current page).

This may be my fault in programming calibre-web, rather than a fault with
epub.js - maybe I am using an inappropriate function to get the epubcfi of
the 'current page' when the location changes.

I have found an example where the epubcfi of a page loads the page two
before the currently displayed page and the paragraph that is at the start
of the displayed page begins two pages before the displayed page. This is
consistent with the problem being that the epubcfi I am getting is for the
start of the paragraph (or whatever text element) that contains the content
at the start of the displayed page but does not include the offset into
that element.

After a page change, rendition.reportedLocation reports the location. But
the location may be determined before this???

rendition.display() calls this.manager.display(section, target), then emits
displayed event then calls rendition.reportLocation(). Maybe
manager.display() determines the location???

manager.display() of the default manager adds the section then, if a target
is provided, calculates and offset (view.locationOf(target)), then a width,
then manager.moveTo(offset, width). Finally, this.views.show().

But maybe that's not the issue.

When clicking next to change page, rendition.next calls manager.next, then
reportLocation().

Manager.next() seems to scroll the container but doesn't appear to generate
a new epubcfi.

So, maybe rendition.reportLocation() is the culprit.

Maybe the problem is that in paginated layout, the pages are produced by
creating columns using CSS and epub.js doesn't actually know what text is
on each column (a.k.a. page). But it has some idea. Why doesn't it know
exactly???

Certainly, the content itself is not divided into pages generated by
epub.js. In the rendered DOM, the content is merely the content doc with
columns generated by CSS, and this content is scrolled to make the
appropriate part visible within the view container.

I think the culprit is in mapping.js, function page(), described as 'Find
CFI paris for a page'.



